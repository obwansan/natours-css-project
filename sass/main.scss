$color-primary: #55c57a;
$color-primary-light: #7ed56f;
$color-primary-dark: #28b485;

$color-grey-dark: #777;
$color-white: #fff;
$color-black: #000;



*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  /* Better practice to set box-sizing on the body element and set it to inherit
  on the universal selector. Means all elements will inherit box-sizing from body
  rather than it being applied directly via the universal selector. */
  box-sizing: inherit;
}

html {
  /* This is the root element, so to work out the rem value of 
     other element font-sizes just divide their pixel value by 10.
     Benefit is you only need to change THIS SINGLE FONT SIZE in media 
     queries and all rem values will change in proportion to it, so
     you don't have to change all the child element font-sizes and 
     other spacing pixel values. 
     
     This is 62.5% of the default browser font-size (which is usually 16px).
     .625*16 = 10, which means if the default browser font-size is used, our
     root font-size will be 10px, and all the rem values will be the pixel value
     divided by 10. 
     */
  font-size: 62.5%;
}

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  color: $color-grey-dark;
  padding: 3rem;
  box-sizing: border-box;
}

.header {
  height: 95vh;
  background-image: linear-gradient(
    to right bottom, 
    rgba($color-primary-light, 0.75), 
    rgba($color-primary-dark, 0.75)), 
    url(../img/hero.jpg);
  background-size: cover;
  background-position: top;
  position: relative;
  /*  */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);

  &__logo-box {
    position: absolute;
    top: 40px;
    left: 4rem;
  }

  &__logo {
    height: 3.5rem;
  }
  
  &__text-box {
    position: absolute;
    top: 33%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
  }
}

.heading-primary {
  color: $color-white;
  text-transform: uppercase;

  /* stops animations shaking when they finish. No one knows why they shake or 
  how this fixes it, it just works! */
  backface-visibility: hidden;
  /* margin uses rem because it's pixels */
  margin-bottom: 6rem;

  &--main {
    display: block;
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
  
    animation-name: moveInLeft;
    animation-duration: 1.2s;
    animation-timing-function: ease-out;
  }
  
  &--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
  
    animation: moveInRight 1.2s ease-out;
  }
}

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }

  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.btn {
  &:link,
  &:visited {
    text-transform: uppercase;
    text-decoration: none;
    padding: 1.5rem 4rem;
    display: inline-block;
    border-radius: 10rem;
    /* this animates all transforms in relation to the initial state */
    transition: all .2;
    position: relative;
    font-size: 1.6rem;
  }

  &:hover {
    transform: translateY(-3px);
    box-shadow: 0 1rem 2rem rgba($color-black, .2);

    /* Apply the btn::after rule when the button is hovered over. 
    The transition on the 'parent' / baseline btn::after element makes it take 
    0.4 seconds to scale. When it finishes it's opacity goes to 0, i.e. it disappears.*/
    &::after {
      transform: scaleX(1.4) scaleY(1.6);
      opacity: 0;
    }
  }

  &:active {
    transform: translateY(-1px);
    box-shadow: 0 .5rem 1rem rgba($color-black, .2);
  }

  &--white {
    background-color: $color-white;
    color: $color-grey-dark;

    /* How does this connect to .btn:hover::after ? */
    &::after {
      background-color: $color-white;
    }
  }

  &::after {
    content: "";
    display: inline-block;
    height: 100%;
    width: 100%;
    border-radius: 100px;
    position: absolute;
    top: 0%;
    left: 0%;
    z-index: -1;
    transition: all 2s;
  }

  &--animated {
    /* animation: name duration timing-function delay */
    animation: moveInBottom .5s ease-out .75s;
    /* At page load, before the animation starts, automatically applies the properties 
       of the 0% state of the moveInBottom animation (i.e. invisible and 30px down from 
       the end position) to the <a> with the .btn-animated class. So the button first 
       appears 30px down and then moves up.*/
    animation-fill-mode: backwards;
  }
}
