/*
COLORS:

Light green: #7ed56f
Medium green: #55c57a
Dark green: #28b485

*/

*,
*::before,
*::after {
  margin: 0;
  padding: 0;
  /* Better practice to set box-sizing on the body element and set it to inherit
  on the universal selector. Means all elements will inherit box-sizing from body
  rather than it being applied directly via the universal selector. */
  box-sizing: inherit;
}

html {
  /* This is the root element, so to work out the rem value of 
     other element font-sizes just divide their pixel value by 10.
     Benefit is you only need to change THIS SINGLE FONT SIZE in media 
     queries and all rem values will change in proportion to it, so
     you don't have to change all the child element font-sizes and 
     other spacing pixel values. 
     
     This is 62.5% of the default browser font-size (which is usually 16px).
     .625*16 = 10, which means if the default browser font-size is used, our
     root font-size will be 10px, and all the rem values will be the pixel value
     divided by 10. 
     */
  font-size: 62.5%;
}

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* font-size: 16px; */
  line-height: 1.7;
  color: #777;
  padding: 3rem;
  box-sizing: border-box;
}

.header {
  height: 95vh;
  background-image: linear-gradient(
    to right bottom, 
    rgba(126, 213, 111, 0.75), 
    #28b485), 
    url(../img/hero.jpg
  );
  background-size: cover;
  background-position: top;
  position: relative;
  /*  */
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
}

.logo-box {
  position: absolute;
  top: 40px;
  left: 4rem;
}

.logo {
  height: 3.5rem;
}

/* position: absolute; positions the text-box in relation to its parent element.
   So the top left corner of the text-box is 40% down and 50% across from the <header>'s
   top left corner. 
   transform: translate(-50%, -50%); positions the text-box in relation to itself, 
   i.e. moves it 50% of its own width left and 50% of its own height up. That's how combining 
   the position and transform responsively centers an element (if top:50% and left:50%).*/
.text-box {
  position: absolute;
  top: 33%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
}

.heading-primary {
  color: #fff;
  text-transform: uppercase;

  /* stops animations shaking when they finish. No one knows why they shake or 
  how this fixes it, it just works! */
  backface-visibility: hidden;
  /* margin uses rem because it's pixels */
  margin-bottom: 6rem;
}

.heading-primary-main {
  display: block;
  font-size: 6rem;
  font-weight: 400;
  letter-spacing: 3.5rem;

  animation-name: moveInLeft;
  animation-duration: 1.2s;
  animation-timing-function: ease-out;
}

.heading-primary-sub {
  display: block;
  font-size: 2rem;
  font-weight: 700;
  letter-spacing: 1.75rem;

  animation: moveInRight 1.2s ease-out;
}

@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem);
  }

  80% {
    transform: translateX(1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem);
  }

  80% {
    transform: translateX(-1rem);
  }

  100% {
    opacity: 1;
    transform: translateX(0);
  }
}

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem);
  }

  100% {
    opacity: 1;
    transform: translateY(0);
  }
}

.btn:link,
.btn:visited {
  text-transform: uppercase;
  text-decoration: none;
  padding: 1.5rem 4rem;
  display: inline-block;
  border-radius: 10rem;
  /* this animates all transforms in relation to the initial state */
  transition: all .2;
  position: relative;
  font-size: 1.6rem;
}

.btn:hover {
  transform: translateY(-3px);
  box-shadow: 0 1rem 2rem rgba(0, 0, 0, .2);
}

.btn:active {
  transform: translateY(-1px);
  box-shadow: 0 .5rem 1rem rgba(0, 0, 0, .2);
}

.btn-white {
  background-color: #fff;
  color: #777;
}

/* Needs to have same properties as the button.
   It has 100% dimensions of the 'parent' button element. 
   Its positioned exactly behind the button. */
.btn::after {
  content: "";
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 100px;
  position: absolute;
  top: 0%;
  left: 0%;
  z-index: -1;
  transition: all 2s;
}

/* How does this connect to .btn:hover::after */
.btn-white::after {
  background-color: #fff;
}

/* Apply the btn::after rule when the button is hovered over. 
   The transition on the 'parent' / baseline btn::after element makes it take 
   0.4 seconds to scale. When it finishes it's opacity goes to 0, i.e. it disappears.*/
.btn:hover::after {
  transform: scaleX(1.4) scaleY(1.6);
  opacity: 0;
}

/*  */
.btn-animated {
  /* animation: name duration timing-function delay */
  animation: moveInBottom .5s ease-out .75s;
  /* At page load, before the animation starts, automatically applies the properties 
     of the 0% state of the moveInBottom animation (i.e. invisible and 30px down from 
     the end position) to the <a> with the .btn-animated class. So the button first 
     appears 30px down and then moves up.*/
  animation-fill-mode: backwards;
}